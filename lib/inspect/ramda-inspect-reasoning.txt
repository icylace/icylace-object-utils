https://github.com/ramda/ramda/issues/2038#issuecomment-270196329




Certainly!  Please forgive the long backstory behind this function. :)

I recently searched for a configuration wizard for [ESLint](http://eslint.org/).  I've only found one that already exists but it's out-of-date, doesn't have the ability to set all the rule-specific configurations, and its UI leaves a lot to be desired.  So, I took it upon myself to make a better one.

Since there are [well over 200 rules](http://eslint.org/docs/rules/) as of ESLint 3.12.2, it's desirable to automate the creation of a configuration wizard UI as much as possible.  Fortunately, each of ESLint's rules has their schema consistently defined using [JSON Schema](http://json-schema.org/).  The basic idea is to of course leverage this metadata to drive the creation of form controls for the wizard interface.

There are a couple issues with this:

  1. Not all rule-specific metadata are encoded in the rule's schema (e.g. default values) even though they're expressed in the rule's documentation.
  2. The JSON Schema format was designed for structural validation of JSON data. It wasn't designed to aid in the generation of UI components.

The first issue will likely require manual effort to address but the second issue is where things get interesting.

My goal for the second issue was to programmatically convert each rule's schema into an internal custom format that I believe will be easier to deal with for my purposes.  My naive initial attempt at this was to do a rote translation of the rule settings into their comparable JavaScript forms.

To illustrate with a basic example, let's look at the [schema for the `func-style` rule](https://github.com/eslint/eslint/blob/v3.12.2/lib/rules/func-style.js#L19):

```json
[
  { "enum": ["declaration", "expression"] },
  {
    "type": "object",
    "properties": {
      "allowArrowFunctions": {
        "type": "boolean"
      }
    },
    "additionalProperties": false
  }
]
```

My naive method simplified this to:

```json
[
  ["declaration", "expression"],
  {
    "props": {
      "allowArrowFunctions": false
    }
  }
]
```

So, my naive method worked pretty well for the majority of the rule schemas but there were some that required additional simplification steps.  One such schema was for [`eqeqeq`](https://github.com/eslint/eslint/blob/v3.12.2/lib/rules/eqeqeq.js#L20):

```json
{
  "anyOf": [
    {
      "type": "array",
      "items": [
        { "enum": ["always"] },
        {
          "type": "object",
          "properties": {
            "null": { "enum": ["always", "never", "ignore"] }
          },
          "additionalProperties": false
        }
      ],
      "additionalItems": false
    },
    {
      "type": "array",
      "items": [{ "enum": ["smart", "allow-null"] }],
      "additionalItems": false
    }
  ]
}
```

My naive method produced:

```json
[
  {
    "anyOf": [
      {
        "array": {
          "choices": [
            ["always"],
            {
              "props": {
                "null": ["always", "never", "ignore"]
              }
            }
          ],
          "moreItemsNotAllowed": true
        }
      },
      {
        "array": {
          "choices": [["smart", "allow-null"]],
          "moreItemsNotAllowed": true
        }
      }
    ]
  }
]
```

But this wasn't sufficient.  What I actually wanted, and what I eventually achieved using a second pass of simplification, was this:

```json
[
  ["always", "smart", "allow-null"],
  {
    "props": {
      "null": ["always", "never", "ignore"]
    },
    "availableFor": ["always"]
  }
]
```

I'll spare you the details of how I did this and other similar conversions but suffice it to say I felt my code could be better.

I then took a step back, thought about it for a while, and came up with the idea of generalizing the pattern matching aspects of what I was doing and placing that into a new helper function that can do this sort of declarative multi-selector type of thing.

This is how `inspect` came to be.

Once I created this function I applied it to my project in a few key places.  For instance, here's a code snippet partially showing how I solved the aforementioned `eqeqeq` case:

```javascript
const spec = {
  anyOf: [
    {
      array: {
        choices: ["primary1", { props: "secondary" }],
      },
    },
    {
      array: {
        choices: ["primary2"],
      },
    },
  ],
}
const inspectee = inspect(spec, schema)
return [
  uniq(concat(inspectee.primary1, inspectee.primary2)),
  {
    props: inspectee.secondary,
    availableFor: inspectee.primary1,
  },
]
```

To me this was clearer than what I would have otherwise done.  As an added bonus, I started seeing potential opportunities for refactoring that I had not noticed before using `inspect`.

In other words, `inspect` made my life a whole lot easier !
